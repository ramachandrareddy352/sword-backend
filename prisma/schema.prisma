generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ======================= ADMIN CONFIG =======================
model AdminConfig {
  id BigInt @id @default(1) @db.UnsignedBigInt

  shieldGoldPrice           Int     @default(1) @db.UnsignedInt // amount used to buy single shield from marketplace
  maxDailyShieldAds         Int     @default(10) @db.UnsignedInt // user can get shields daily by watching the ads
  maxShieldHold             Int     @default(10) @db.UnsignedInt // maximum shields can be hold by user, can be set sa `0`, if `0` then there is no restriction
  shieldActiveOnMarketplace Boolean @default(true) // when it is true, then only user can able to buy shields from marketplace

  // new registrations get as default
  defaultTrustPoints Int @default(100) @db.UnsignedInt // can be `0`
  defaultGold        Int @default(5000) @db.UnsignedInt // can be `0`

  maxDailySwordAds Int @default(10) @db.UnsignedInt // we provide level-1 sword
  swordLevelReward Int @default(1) @db.UnsignedInt // sword level that we give as gift after viewing ad

  maxDailyGoldAds Int @default(10) @db.UnsignedInt // if `0` then there is no restriction
  goldReward      Int @default(10) @db.UnsignedInt // when user view ad we give that much gold to user

  minVoucherGold    Int     @default(10) @db.UnsignedInt
  maxVoucherGold    Int     @default(1000) @db.UnsignedInt
  voucherExpiryDays Int     @default(7) @db.UnsignedInt // if `0` then no need to check for expiry
  expiryAllow       Boolean @default(false)

  isShoppingAllowed Boolean @default(true) // if true, usres can use gold cooins in other shopping app

  adminEmailId String
  updatedAt    DateTime @updatedAt

  @@index([adminEmailId])
}

// ======================= USERS =======================
model User {
  id          BigInt  @id @default(autoincrement()) @db.UnsignedBigInt
  email       String  @unique
  name        String
  profileLogo String?
  password    String // Hashed password (bcrypt in application logic)

  gold            Int     @default(0) @db.UnsignedInt
  trustPoints     Int     @default(100) @db.UnsignedInt
  totalShields    Int     @default(0) @db.UnsignedInt
  anvilSwordLevel BigInt? @unique @db.UnsignedBigInt // atleast sword should be in anvil(main), if sword is lost during upgrade, so we use optional here

  createdAt    DateTime  @default(now())
  lastReviewed DateTime // the last time the account is reviewed (e.g., for verification status)
  lastLoginAt  DateTime?

  oneDayGoldAdsViewed   Int @default(0) @db.UnsignedInt
  oneDayShieldAdsViewed Int @default(0) @db.UnsignedInt
  oneDaySwordAdsViewed  Int @default(0) @db.UnsignedInt

  totalAdsViewed    Int @default(0) @db.UnsignedInt
  totalMissionsDone Int @default(0) @db.UnsignedInt

  isShieldOn Boolean @default(false) // is shield protection on or not
  isBanned   Boolean @default(false) // admin can block or unblock the user

  createdVouchers  UserVoucher[] @relation("CreatedVouchers")
  allowedVouchers  UserVoucher[] @relation("AllowedVouchers")
  redeemedVouchers UserVoucher[] @relation("RedeemedVouchers")

  swords    UserSword[]
  materials UserMaterial[]

  gifts            UserGift[]
  customerSupports CustomerSupport[]

  swordMarketplacePurchases    SwordMarketplacePurchase[]
  materialMarketplacePurchases MaterialMarketplacePurchase[]
  shieldMarketplacePurchases   ShieldMarketplacePurchase[]

  swordSynthesisHistories SwordSynthesisHistory[]
  swordUpgradeHistories   SwordUpgradeHistory[]

  userDailyMissionProgresses   UserDailyMissionProgress[]
  userOneTimeMissionProgresses UserOneTimeMissionProgress[]
  adRewardSessions             AdRewardSession[]

  swordSellHistories    SwordSellHistory[]
  materialSellHistories MaterialSellHistory[]

  @@index([anvilSwordLevel])
}

// ========================== USER VOUCHERS ========================= //
model UserVoucher {
  id   BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  code String @unique // secure random voucher code

  // Creator (who locked gold)
  createdById BigInt @db.UnsignedBigInt

  // Who is allowed to redeem
  allowedUserId BigInt? @db.UnsignedBigInt // only set to others, not him self and. if he want to use this then set to null

  goldAmount Int           @db.UnsignedInt
  status     VoucherStatus @default(PENDING)

  redeemedById BigInt? @db.UnsignedBigInt // who redeemed this?

  updatedAt DateTime? // (last status change)redeemedAt | cancelledAt | expiresAt. we upadte this ater any action done
  createdAt DateTime  @default(now())

  createdBy   User  @relation("CreatedVouchers", fields: [createdById], references: [id], onDelete: Cascade)
  allowedUser User? @relation("AllowedVouchers", fields: [allowedUserId], references: [id], onDelete: SetNull)
  redeemedBy  User? @relation("RedeemedVouchers", fields: [redeemedById], references: [id], onDelete: SetNull)

  @@index([createdById])
  @@index([allowedUserId])
  @@index([redeemedById])
  @@index([status])
}

enum VoucherStatus {
  PENDING // created, not used
  REDEEMED // used on shopping website
  CANCELLED // user cancelled, gold refunded
  EXPIRED // expired, gold refunded
}

model DailyMissionDefinition {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  title       String
  description String

  isActive Boolean @default(true)

  // Dynamic condition system
  // Example:
  // [
  //   {"type": "ownSwords", "minCount": 10},
  //   {"type": "upgradeSword", "minLevel": 5}
  // ]
  conditions Json

  targetValue Int @db.UnsignedInt // e.g. do 5 times

  // Dynamic reward:
  // {"type": "gold", "amount": 100}
  // {"type": "trustPoints", "amount": 50}
  // {"type": "sword", "level": 3}
  // {"type": "material", "materialId": 12, "quantity": 5}
  // {"type": "shield", "quantity": 2}
  reward Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  progress UserDailyMissionProgress[]
}

model UserDailyMissionProgress {
  userId    BigInt @db.UnsignedBigInt
  missionId BigInt @db.UnsignedBigInt

  claimedTimes  Int       @db.UnsignedInt // how many times users claimed this mission(increases every time)
  lastClaimedAt DateTime?

  user    User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  mission DailyMissionDefinition @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@id([userId, missionId])
  @@index([userId])
  @@index([missionId])
}

model OneTimeMissionDefinition {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  title       String
  description String

  isActive Boolean @default(true)

  startAt   DateTime
  expiresAt DateTime?

  // Dynamic structured conditions
  // Example:
  // [
  //   {"type": "synthesize", "level": 5},
  //   {"type": "buyMaterial", "materialId": 10, "minQuantity": 3}
  // ]
  conditions Json

  targetValue Int @db.UnsignedInt

  reward Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  progress UserOneTimeMissionProgress[]
}

model UserOneTimeMissionProgress {
  userId    BigInt   @db.UnsignedBigInt
  missionId BigInt   @db.UnsignedBigInt
  claimedAt DateTime @default(now())

  user    User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  mission OneTimeMissionDefinition @relation(fields: [missionId], references: [id], onDelete: Cascade)

  @@id([userId, missionId])
  @@index([userId])
  @@index([missionId])
}

model AdRewardSession {
  id         BigInt       @id @default(autoincrement())
  userId     BigInt       @db.UnsignedBigInt
  nonce      String       @unique
  rewardType AdRewardType
  rewarded   Boolean      @default(false)

  createdAt  DateTime  @default(now())
  rewardedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum AdRewardType {
  GOLD
  OLD_SWORD
  SHIELD
}

// ======================= SWORD DEFINITIONS ======================= //
model SwordLevelDefinition {
  id    BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  level Int    @unique @db.UnsignedInt // 1, 2, 3 ... 100(min = 1 & max = 100)

  name           String  @unique // sword name at this level
  image          String // sword image at this level
  description    String? @db.Text
  synthesizeName String  @unique // sword synthesize process name at this level

  upgradeCost    Int   @db.UnsignedInt
  buyingCost     Int   @db.UnsignedInt
  sellingCost    Int   @db.UnsignedInt
  synthesizeCost Int   @db.UnsignedInt
  successRate    Float // probability of upgrade success

  isBuyingAllow     Boolean @default(true) // when it is true, then only user can able to buy this level sword from marketplace
  isSellingAllow    Boolean @default(true) // when it is true, then only user can able to sell it and get selling cost gold to his balance
  isSynthesizeAllow Boolean @default(true) // when it is true, then only user can able to sell it and get selling cost gold to his balance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  synthesisRequirements SwordSynthesisRequirement[]
  upgradeDrops          SwordUpgradeDrop[]

  userSwords                UserSword[]
  swordMarketplacePurchases SwordMarketplacePurchase[]
  swordSellHistories        SwordSellHistory[]
  swordSynthesisHistories   SwordSynthesisHistory[]
  swordUpgradeHistories     SwordUpgradeHistory[]
  userGifts                 UserGift[]
}

model SwordSynthesisRequirement {
  swordLevelDefinitionId BigInt @db.UnsignedBigInt
  materialId             BigInt @db.UnsignedBigInt

  requiredQuantity Int @db.UnsignedInt

  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id], onDelete: Cascade)
  material             Material             @relation(fields: [materialId], references: [id])

  @@unique([swordLevelDefinitionId])
  @@index([materialId])
}

model SwordUpgradeDrop {
  swordLevelDefinitionId BigInt @db.UnsignedBigInt
  materialId             BigInt @db.UnsignedBigInt

  dropPercentage Int @db.UnsignedInt // sum = 100 per sword level
  minQuantity    Int @db.UnsignedInt // can be zero also
  maxQuantity    Int @db.UnsignedInt

  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id], onDelete: Cascade)
  material             Material             @relation(fields: [materialId], references: [id])

  @@unique([swordLevelDefinitionId])
  @@index([materialId])
}

model SwordSynthesisHistory {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId                 BigInt @db.UnsignedBigInt
  swordLevelDefinitionId BigInt @db.UnsignedBigInt
  goldSpent              Int    @db.UnsignedInt

  createdAt DateTime @default(now())

  user                 User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model SwordUpgradeHistory {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId BigInt @db.UnsignedBigInt

  fromSwordLevelId BigInt  @db.UnsignedBigInt
  toSwordLevelId   BigInt? @db.UnsignedBigInt

  success   Boolean // is upgrade success or failed
  goldSpent Int     @db.UnsignedInt

  droppedMaterialId BigInt? @db.UnsignedBigInt
  droppedQuantity   Int?

  createdAt DateTime @default(now())

  user                     User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  fromSwordLevelDefinition SwordLevelDefinition @relation(fields: [fromSwordLevelId], references: [id], onDelete: Cascade)
  toSwordLevelDefinition   SwordLevelDefinition @relation(fields: [toSwordLevelId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model SwordSellHistory {
  id                     BigInt   @id @default(autoincrement()) @db.UnsignedBigInt
  userId                 BigInt   @db.UnsignedBigInt
  swordLevelDefinitionId BigInt   @db.UnsignedBigInt
  quantity               Int      @db.UnsignedInt
  priceGold              Int      @db.UnsignedInt // total received
  soldAt                 DateTime @default(now())

  user                 User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id], onDelete: Restrict)

  @@index([userId, soldAt(sort: Desc)]) // user's sell history
  @@index([swordLevelDefinitionId, soldAt])
}

model UserSword {
  userId  BigInt @db.UnsignedBigInt
  swordId Int    @db.UnsignedInt // references SwordLevelDefinition.level

  isOnAnvil      Boolean @default(false)
  unsoldQuantity Int     @default(0) @db.UnsignedInt
  soldedQuantity Int     @default(0) @db.UnsignedInt
  brokenQuantity Int     @default(0) @db.UnsignedInt

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user                 User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordId], references: [id], onDelete: Cascade)

  @@id([userId, swordId])
  @@index([swordId])
  @@index([userId])
}

// =========================== MATERIAL =========================== //
model Material {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  name        String         @unique
  description String?        @db.Text
  image       String
  rarity      MaterialRarity @default(COMMON)

  sellingCost    Int     @db.UnsignedInt
  buyingCost     Int     @db.UnsignedInt
  isBuyingAllow  Boolean @default(true) // when it is true, then only user can able to buy this material from marketplace
  isSellingAllow Boolean @default(true) // when it is true, then only user can able to sell itand get selling cost gold to his balance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  materialMarketplaceItems   MaterialMarketplacePurchase[]
  materialSellHistories      MaterialSellHistory[]
  userMaterials              UserMaterial[]
  swordSynthesisRequirements SwordSynthesisRequirement[]
  swordUpgradeDrops          SwordUpgradeDrop[]
  userGifts                  UserGift[]
}

enum MaterialRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
}

model MaterialSellHistory {
  id         BigInt   @id @default(autoincrement()) @db.UnsignedBigInt
  userId     BigInt   @db.UnsignedBigInt
  materialId BigInt   @db.UnsignedBigInt
  quantity   Int      @db.UnsignedInt
  priceGold  Int      @db.UnsignedInt
  soldAt     DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id], onDelete: Restrict)

  @@index([userId, soldAt(sort: Desc)])
  @@index([materialId])
}

model UserMaterial {
  userId     BigInt @db.UnsignedBigInt
  materialId BigInt @db.UnsignedBigInt

  unsoldQuantity Int @default(0) @db.UnsignedInt // always add in one and subtract from other
  soldedQuantity Int @default(0) @db.UnsignedInt

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id], onDelete: Cascade)

  @@id([userId, materialId])
  @@index([userId])
  @@index([materialId])
}

// ========================== USER GIFTS ========================== //
model UserGift {
  id         BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  receiverId BigInt @db.UnsignedBigInt

  status GiftStatus @default(PENDING)
  note   String? // optional admin / sender note

  // ─── Gift content (exactly one of these should be non-null) ───────────────────────
  type GiftItemType

  // For GOLD, TRUST_POINTS, SHIELD
  amount Int? @db.UnsignedInt

  // For MATERIAL
  materialId       BigInt?   @db.UnsignedBigInt
  materialQuantity Int?      @db.UnsignedInt
  material         Material? @relation(fields: [materialId], references: [id], onDelete: Cascade)

  // For SWORD
  swordId              Int?                  @db.UnsignedInt
  swordQuantity        Int?                  @db.UnsignedInt
  swordLevelDefinition SwordLevelDefinition? @relation(fields: [swordId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt   DateTime  @default(now())
  cancelledAt DateTime?
  claimedAt   DateTime?

  // Relations
  receiver User? @relation(fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([receiverId, status]) // → "show all pending gifts for this user"
  @@index([type, createdAt(sort: Desc)])
  @@index([status, createdAt(sort: Desc)]) // → "recent pending/claimed gifts", admin view
  @@index([receiverId, claimedAt]) // → "what has this user already claimed"
  @@index([createdAt(sort: Desc)]) // → global recent gifts (admin)
}

enum GiftStatus {
  PENDING // sent but not opened
  CLAIMED
  CANCELLED
}

enum GiftItemType {
  GOLD
  TRUST_POINTS
  MATERIAL
  SWORD
  SHIELD
}

// ========================= MARKETPLACE ========================= //
model SwordMarketplacePurchase {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId                 BigInt @db.UnsignedBigInt
  swordLevelDefinitionId BigInt @db.UnsignedBigInt // this maps to current status of the sword
  quantity               Int    @default(1) @db.UnsignedInt

  priceGold   Int      @db.UnsignedInt // quantity * prize of single sword
  purchasedAt DateTime @default(now())

  user                 User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([swordLevelDefinitionId])
}

model MaterialMarketplacePurchase {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId     BigInt @db.UnsignedBigInt
  materialId BigInt @db.UnsignedBigInt
  quantity   Int    @db.UnsignedInt

  priceGold   Int      @db.UnsignedInt // quantity * price of single unit
  purchasedAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([materialId])
}

model ShieldMarketplacePurchase {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId   BigInt @db.UnsignedBigInt
  quantity Int    @db.UnsignedInt

  priceGold   Int      @db.UnsignedInt // quantity * price of single unit
  purchasedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ======================= CUSTOMER SUPPORT ======================= //
model CustomerSupport {
  id     BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  userId BigInt @db.UnsignedBigInt

  category SupportCategory
  priority SupportPriority @default(NORMAL)

  title   String
  content String
  message String

  adminReply String? @db.Text
  isReviewed Boolean @default(false)

  createdAt  DateTime  @default(now())
  updatedAt  DateTime? @updatedAt
  reviewedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum SupportCategory {
  GAME_BUG
  PAYMENT
  ACCOUNT
  BAN_APPEAL
  SUGGESTION
  OTHER
}

enum SupportPriority {
  LOW
  NORMAL
  HIGH
  CRITICAL
}
