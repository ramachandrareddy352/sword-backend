generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// ======================= ADMIN CONFIG =======================
model AdminConfig {
  id BigInt @id @default(1) @db.UnsignedBigInt

  shieldGoldPrice           Int     @default(1) @db.UnsignedInt // amount used to buy single shield from marketplace
  maxDailyShieldAds         Int     @default(1) @db.UnsignedInt // user can get shields daily by watching the ads
  maxShieldHold             Int     @default(1) @db.UnsignedInt // maximum shields can be hold by user, can be set sa `0`, if `0` then there is no restriction
  shieldActiveOnMarketplace Boolean @default(true) // when it is true, then only user can able to buy shields from marketplace

  maxDailyAds        Int @default(10) @db.UnsignedInt // if `0` then there is no restriction
  maxDailyMissions   Int @default(20) @db.UnsignedInt // if `0` then there is no restriction
  defaultTrustPoints Int @default(100) @db.UnsignedInt // can be `0`
  defaultGold        Int @default(5000) @db.UnsignedInt // can be `0`

  minVoucherGold    Int     @default(10) @db.UnsignedInt
  maxVoucherGold    Int     @default(1000) @db.UnsignedInt
  voucherExpiryDays Int     @default(7) @db.UnsignedInt // if `0` then no need to check for expiry
  expiryAllow       Boolean @default(false)

  adminEmailId String
  updatedAt    DateTime @updatedAt

  @@index([adminEmailId])
}

// ======================= USERS =======================
model User {
  id          BigInt  @id @default(autoincrement()) @db.UnsignedBigInt
  email       String  @unique
  name        String
  profileLogo String?
  password    String // Hashed password (bcrypt in application logic)

  gold         Int     @default(0) @db.UnsignedInt
  trustPoints  Int     @default(100) @db.UnsignedInt
  totalShields Int     @default(0) @db.UnsignedInt
  anvilSwordId BigInt? @unique @db.UnsignedBigInt // atleast sword should be in anvil(main), if sword is lost during upgrade, so we use optional here

  createdAt    DateTime  @default(now())
  lastReviewed DateTime // the last time the account is reviewed (e.g., for verification status)
  lastLoginAt  DateTime?

  oneDayAdsViewed       Int @default(0) @db.UnsignedInt // maximum fetch from the admin config (make level wise views, like some people have 10 ads, some people having badges have some more ads to view)
  totalAdsViewed        Int @default(0) @db.UnsignedInt
  oneDayShieldAdsViewed Int @default(0) @db.UnsignedInt

  todayMissionsDone Int @default(0) @db.UnsignedInt // check the maximum limi from admin config
  totalMissionsDone Int @default(0) @db.UnsignedInt

  isShieldOn Boolean @default(false) // is shield protection on or not
  isBanned   Boolean @default(false) // admin can block or unblock the user
  soundOn    Boolean @default(true)

  anvilSword UserSword? @relation("UserAnvilSword", fields: [anvilSwordId], references: [id], onDelete: SetNull)

  swords                       UserSword[]                   @relation("UserOwnedSwords")
  materials                    UserMaterial[] // materials can be buy from market or gifts or as by-products when sword is broken
  gifts                        UserGift[]
  customerSupports             CustomerSupport[] // complaints given by the user
  // missions UserMission[] // missions done or on hold, have to set daily, and normal missions
  vouchers                     UserVoucher[] // vouchers created by user to use them in shopping app
  swordMarketplacePurchases    SwordMarketplacePurchase[]
  materialMarketplacePurchases MaterialMarketplacePurchase[]
  shieldMarketplacePurchases   ShieldMarketplacePurchase[]
  swordSynthesisHistories      SwordSynthesisHistory[]
  swordUpgradeHistories        SwordUpgradeHistory[]
}

// ======================= SWORD DEFINITIONS ======================= //
model SwordLevelDefinition {
  id    BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  level Int    @unique @db.UnsignedInt // 0, 1, 2, 3 ... 100

  name        String  @unique // sword name at this level
  image       String // sword image at this level
  description String?

  upgradeCost    Int   @db.UnsignedInt
  buyingCost     Int   @db.UnsignedInt
  sellingCost    Int   @db.UnsignedInt
  synthesizeCost Int   @db.UnsignedInt
  successRate    Float // probability of upgrade success

  isBuyingAllow     Boolean @default(true) // when it is true, then only user can able to buy this level sword from marketplace
  isSellingAllow    Boolean @default(true) // when it is true, then only user can able to sell it and get selling cost gold to his balance
  isSynthesizeAllow Boolean @default(true) // when it is true, then only user can able to sell it and get selling cost gold to his balance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  synthesisRequirements SwordSynthesisRequirement[]
  upgradeDrops          SwordUpgradeDrop[]

  userSwords                UserSword[]
  userGiftItems             UserGiftItem[]
  swordMarketplacePurchases SwordMarketplacePurchase[]
  swordSynthesisHistories   SwordSynthesisHistory[]
}

model SwordSynthesisRequirement {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  swordLevelDefinitionId BigInt @db.UnsignedBigInt
  materialId             BigInt @db.UnsignedBigInt

  requiredQuantity Int @db.UnsignedInt

  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id], onDelete: Cascade)
  material             Material             @relation(fields: [materialId], references: [id])

  @@unique([swordLevelDefinitionId, materialId])
  @@index([materialId])
}

model SwordUpgradeDrop {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  swordLevelDefinitionId BigInt @db.UnsignedBigInt
  materialId             BigInt @db.UnsignedBigInt

  dropPercentage Int @db.UnsignedInt // sum = 100 per sword level
  minQuantity    Int @db.UnsignedInt
  maxQuantity    Int @db.UnsignedInt

  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id], onDelete: Cascade)
  material             Material             @relation(fields: [materialId], references: [id])

  @@unique([swordLevelDefinitionId, materialId])
}

model SwordSynthesisHistory {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId                 BigInt @db.UnsignedBigInt
  swordLevelDefinitionId BigInt @db.UnsignedBigInt

  createdSwordId BigInt? @db.UnsignedBigInt
  goldSpent      Int     @db.UnsignedInt

  createdAt DateTime @default(now())

  user                 User                 @relation(fields: [userId], references: [id])
  swordLevelDefinition SwordLevelDefinition @relation(fields: [swordLevelDefinitionId], references: [id])
  createdSword         UserSword?           @relation(fields: [createdSwordId], references: [id])
}

model SwordUpgradeHistory {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId  BigInt @db.UnsignedBigInt
  swordId BigInt @db.UnsignedBigInt

  fromSwordLevelId BigInt  @db.UnsignedBigInt
  toSwordLevelId   BigInt? @db.UnsignedBigInt

  success   Boolean
  goldSpent Int     @db.UnsignedInt

  droppedMaterialId BigInt? @db.UnsignedBigInt
  droppedQuantity   Int?

  createdAt DateTime @default(now())

  user  User      @relation(fields: [userId], references: [id])
  sword UserSword @relation(fields: [swordId], references: [id])
}

model UserSword {
  id   BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  code String @unique // unique 12-digit sword code

  userId                 BigInt  @db.UnsignedBigInt
  level                  Int     @db.UnsignedInt
  isOnAnvil              Boolean
  swordLevelDefinitionId BigInt  @db.UnsignedBigInt
  isSolded               Boolean @default(false)
  isBroken               Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user                      User                       @relation("UserOwnedSwords", fields: [userId], references: [id], onDelete: Cascade)
  anvilOwner                User?                      @relation("UserAnvilSword")
  swordLevelDefinition      SwordLevelDefinition       @relation(fields: [swordLevelDefinitionId], references: [id])
  swordMarketplacePurchases SwordMarketplacePurchase[]
  swordSynthesisHistories   SwordSynthesisHistory[]
  swordUpgradeHistories     SwordUpgradeHistory[]

  @@index([userId])
}

// ========================== USER VOUCHERS ========================= //
model UserVoucher {
  id   BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  code String @unique // secure random voucher code

  userId     BigInt        @db.UnsignedBigInt
  goldAmount Int           @db.UnsignedInt // locked gold amount
  status     VoucherStatus @default(PENDING)

  redeemedAt  DateTime?
  cancelledAt DateTime?
  expiresAt   DateTime?
  createdAt   DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

enum VoucherStatus {
  PENDING // created, not used
  REDEEMED // used on shopping website
  CANCELLED // user cancelled, gold refunded
  EXPIRED // expired, gold refunded
}

// =========================== MATERIAL =========================== //
model Material {
  id   BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  code String @unique

  name        String         @unique
  description String?
  image       String
  rarity      MaterialRarity @default(COMMON)

  sellingCost    Int     @db.UnsignedInt
  buyingCost     Int     @db.UnsignedInt
  isBuyingAllow  Boolean @default(true) // when it is true, then only user can able to buy this material from marketplace
  isSellingAllow Boolean @default(true) // when it is true, then only user can able to sell itand get selling cost gold to his balance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  materialMarketplaceItems   MaterialMarketplacePurchase[]
  userMaterials              UserMaterial[]
  userGiftItems              UserGiftItem[]
  swordSynthesisRequirements SwordSynthesisRequirement[]
  swordUpgradeDrops          SwordUpgradeDrop[]
}

enum MaterialRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
}

model UserMaterial {
  userId     BigInt @db.UnsignedBigInt
  materialId BigInt @db.UnsignedBigInt

  unsoldQuantity Int @default(0) @db.UnsignedInt // always add in one and subtract from other
  soldedQuantity Int @default(0) @db.UnsignedInt

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  material Material @relation(fields: [materialId], references: [id])

  @@id([userId, materialId])
  @@index([materialId])
}

// ========================== USER GIFTS ========================== //
model UserGift {
  id         BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  receiverId BigInt @db.UnsignedBigInt

  status GiftStatus @default(PENDING)
  note   String? // optional admin note

  createdAt   DateTime  @default(now())
  cancelledAt DateTime?
  claimedAt   DateTime?

  items UserGiftItem[]
  user  User?          @relation(fields: [receiverId], references: [id])

  @@index([receiverId])
  @@index([status])
}

model UserGiftItem {
  id     BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  giftId BigInt @db.UnsignedBigInt

  type GiftItemType

  // Gold / Trust points / Shields
  amount Int? @db.UnsignedInt

  // Material relation
  materialId       BigInt?   @db.UnsignedBigInt
  materialQunatity Int?      @db.UnsignedInt
  material         Material? @relation(fields: [materialId], references: [id], onDelete: SetNull)

  // Sword relation
  swordLevel           Int?                  @db.UnsignedInt
  swordLevelDefinition SwordLevelDefinition? @relation(fields: [swordLevel], references: [level], onDelete: SetNull)

  gift UserGift @relation(fields: [giftId], references: [id], onDelete: Cascade)

  @@index([giftId])
  @@index([materialId])
  @@index([swordLevel])
}

enum GiftStatus {
  PENDING // sent but not opened
  CLAIMED
  CANCELLED
}

enum GiftItemType {
  GOLD
  TRUST_POINTS
  MATERIAL
  SWORD
  SHIELD
}

// ========================= MARKETPLACE ========================= //
model SwordMarketplacePurchase {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId                 BigInt @db.UnsignedBigInt
  swordId                BigInt @db.UnsignedBigInt // this maps to current status of the sword
  swordLevelDefinitionId BigInt @db.UnsignedBigInt // this is map to on which levle the sword is bough

  priceGold   Int      @db.UnsignedInt
  purchasedAt DateTime @default(now())

  user                 User                  @relation(fields: [userId], references: [id])
  swordLevelDefinition SwordLevelDefinition? @relation(fields: [swordLevelDefinitionId], references: [id])
  userSword            UserSword?            @relation(fields: [swordId], references: [id])

  @@index([userId])
  @@index([swordId])
  @@index([swordLevelDefinitionId])
}

model MaterialMarketplacePurchase {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId     BigInt @db.UnsignedBigInt
  materialId BigInt @db.UnsignedBigInt
  quantity   Int    @db.UnsignedInt

  priceGold   Int      @db.UnsignedInt // quantity * price of single unit
  purchasedAt DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id])
  material Material @relation(fields: [materialId], references: [id])

  @@index([userId])
}

model ShieldMarketplacePurchase {
  id BigInt @id @default(autoincrement()) @db.UnsignedBigInt

  userId   BigInt @db.UnsignedBigInt
  quantity Int    @db.UnsignedInt

  priceGold   Int      @db.UnsignedInt // quantity * price of single unit
  purchasedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}

// ======================= CUSTOMER SUPPORT ======================= //
model CustomerSupport {
  id     BigInt @id @default(autoincrement()) @db.UnsignedBigInt
  userId BigInt @db.UnsignedBigInt

  category SupportCategory
  priority SupportPriority @default(NORMAL)

  title   String
  content String
  message String

  adminReply String? @db.Text
  isReviewed Boolean @default(false)

  createdAt  DateTime  @default(now())
  updatedAt  DateTime? @updatedAt
  reviewedAt DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

enum SupportCategory {
  GAME_BUG
  PAYMENT
  ACCOUNT
  BAN_APPEAL
  SUGGESTION
  OTHER
}

enum SupportPriority {
  LOW
  NORMAL
  HIGH
  CRITICAL
}
